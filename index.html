<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>OpenAI Voice Assistant</title>
    <meta name="viewport" content="width=device-width">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0d1117;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chat {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .msg {
            margin-bottom: 20px;
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 10px;
            line-height: 1.4;
        }

        .user {
            background: #1f6feb;
            margin-left: auto;
        }

        .assistant {
            background: #30363d;
            margin-right: auto;
        }

        .status {
            background: #161b22;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            color: #8b949e;
            margin-bottom: 10px;
        }

        #recordBtn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: #ff4757;
            margin: 20px auto;
            cursor: pointer;
            transition: .2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: white;
        }

        #recordBtn.recording {
            background: #2ed573;
            animation: pulse 1s infinite;
        }

        #recordBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #8b949e;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="chat"></div>

<button id="recordBtn">üé§</button>

<audio id="player" preload="auto"></audio>

<script>
    // URL WS-—Å–µ—Ä–≤–µ—Ä–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ª–æ–∫–∞–ª—å–Ω—ã–π, –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å)
    let STREAMING_SERVER_URL;
    if (window.location.protocol === 'file:' || !window.location.hostname) {
        STREAMING_SERVER_URL = 'ws://localhost:3000/realtime';
    } else if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        STREAMING_SERVER_URL = `ws://${window.location.hostname}:3000/realtime`;
    } else {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        STREAMING_SERVER_URL = `${wsProtocol}//${window.location.host}/realtime`;
    }
    
    console.log('WS URL:', STREAMING_SERVER_URL);

    let mediaRecorder;
    let ws;
    let isRecording = false;
    let audioContext = null;
    let audioSource = null;
    let audioProcessor = null;
    let micStream = null;

    // === PLAYBACK FOR REALTIME PCM AUDIO ===
    let playbackContext = null;
    let audioQueue = [];
    let isPlaying = false;
    let playbackTime = 0; // –í—Ä–µ–º—è, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ —á–∞–Ω–∫–∞

    function initPlaybackContext() {
        if (!playbackContext || playbackContext.state === 'closed') {
            playbackContext = new AudioContext({ sampleRate: 24000 });
        }
        if (playbackContext.state === 'suspended') {
            playbackContext.resume();
        }
    }

    function enqueueAudioChunk(pcm16buffer) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã –¥–ª—è PCM16 (–¥–ª–∏–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–∞ 2 –±–∞–π—Ç–∞–º)
        if (!pcm16buffer || pcm16buffer.byteLength === 0) {
            console.warn('Empty or invalid audio chunk received');
            return;
        }

        if (pcm16buffer.byteLength % 2 !== 0) {
            console.warn('Audio chunk length is not multiple of 2, skipping:', pcm16buffer.byteLength);
            return;
        }

        // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ö–æ—Ç—è –±—ã –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—ç–º–ø–ª–æ–≤
        if (pcm16buffer.byteLength < 100) {
            console.warn('Audio chunk too small, skipping:', pcm16buffer.byteLength);
            return;
        }

        initPlaybackContext();
        audioQueue.push(pcm16buffer);
        if (!isPlaying) {
            playbackTime = playbackContext.currentTime;
            playNextChunk();
        }
    }

    function playNextChunk() {
        if (audioQueue.length === 0) {
            isPlaying = false;
            return;
        }
        isPlaying = true;

        const chunk = audioQueue.shift();
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º Int16Array
        if (chunk.byteLength % 2 !== 0) {
            console.warn('Skipping invalid chunk in playNextChunk:', chunk.byteLength);
            playNextChunk(); // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ—Ç —á–∞–Ω–∫ –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É
            return;
        }

        // –ß–∏—Ç–∞–µ–º PCM16 –¥–∞–Ω–Ω—ã–µ
        const dataView = new DataView(chunk);
        const sampleCount = chunk.byteLength / 2;
        const float32 = new Float32Array(sampleCount);

        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è Int16 –≤ Float32
        // –ü—Ä–æ–±—É–µ–º little-endian (—Å—Ç–∞–Ω–¥–∞—Ä—Ç –¥–ª—è PCM16)
        let maxValue = 0;
        let minValue = 0;
        
        for (let i = 0; i < sampleCount; i++) {
            // –ß–∏—Ç–∞–µ–º Int16 —Å little-endian –ø–æ—Ä—è–¥–∫–æ–º –±–∞–π—Ç–æ–≤
            const int16Value = dataView.getInt16(i * 2, true);
            
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤ –¥–∏–∞–ø–∞–∑–æ–Ω [-1.0, 1.0]
            float32[i] = int16Value / 32768.0;
            
            // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            if (int16Value > maxValue) maxValue = int16Value;
            if (int16Value < minValue) minValue = int16Value;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
            if (float32[i] > 1.0) float32[i] = 1.0;
            if (float32[i] < -1.0) float32[i] = -1.0;
        }
        
        // –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—ç–º–ø–ª–æ–≤ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–≤—ã—Ö —á–∞–Ω–∫–æ–≤)
        if (audioQueue.length === 0 && sampleCount > 0) {
            console.log('Audio chunk stats:', {
                samples: sampleCount,
                duration: (sampleCount / 24000).toFixed(3) + 's',
                int16Range: `[${minValue}, ${maxValue}]`,
                firstSamples: Array.from(float32.slice(0, 5)).map(v => v.toFixed(4))
            });
        }

        const buffer = playbackContext.createBuffer(1, float32.length, 24000);
        buffer.copyToChannel(float32, 0);

        const source = playbackContext.createBufferSource();
        source.buffer = buffer;
        source.connect(playbackContext.destination);

        // –í—ã—á–∏—Å–ª—è–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —á–∞–Ω–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        const duration = buffer.duration;
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –Ω—É–∂–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –ø–ª–∞–≤–Ω–æ–π —Å–∫–ª–µ–π–∫–∏
        source.start(playbackTime);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —á–∞–Ω–∫–∞
        playbackTime += duration;

        source.onended = () => playNextChunk();
    }

    const chat = document.getElementById("chat");
    const recBtn = document.getElementById("recordBtn");
    const player = document.getElementById("player");

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è sessionId
    let sessionId = localStorage.getItem('sessionId');
    if (!sessionId) {
        sessionId = crypto.randomUUID();
        localStorage.setItem('sessionId', sessionId);
    }

    function addMessage(text, who) {
        const div = document.createElement("div");
        div.className = "msg " + who;
        div.textContent = text;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        return div;
    }

    function addStatus(text) {
        const div = document.createElement("div");
        div.className = "status";
        div.innerHTML = `<span class="loading"></span> ${text}`;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        return div;
    }

    // –ü—Ä–æ—Å—Ç–∞—è —Ä–∞–±–æ—Ç–∞ —Å WS-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ–º
    function ensureWebSocket() {
        if (ws && ws.readyState === WebSocket.OPEN) return ws;

        ws = new WebSocket(STREAMING_SERVER_URL);

        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            console.log('WS connected');
        };

        ws.onclose = () => {
            console.log('WS closed');
        };

        ws.onerror = (e) => {
            console.error('WS error', e);
        };

        ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                enqueueAudioChunk(event.data);
                return;
            }

            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è Realtime API –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç
            if (typeof event.data === 'string') {
                try {
                    const msg = JSON.parse(event.data);
                    console.log('WS EVENT FROM OPENAI:', msg);

                    // –ü—Ä–∏ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –æ—á–∏—â–∞–µ–º –æ—á–µ—Ä–µ–¥—å –∞—É–¥–∏–æ
                    if (msg.type === 'response.created') {
                        audioQueue = [];
                        isPlaying = false;
                        playbackTime = 0;
                        if (playbackContext) {
                            playbackContext.close().catch(() => {});
                            playbackContext = null;
                        }
                        console.log('New response started, cleared audio queue');
                    }

                    // –£–ø—Ä–æ—â—ë–Ω–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞ —Å –≥–æ—Ç–æ–≤—ã–º —Ç–µ–∫—Å—Ç–æ–º
                    if (msg.type === 'assistant.text' && msg.text) {
                        addMessage(msg.text, "assistant");
                        return;
                    }
                                    
                    if (msg.type === 'response.output_text.delta' && msg.delta) {
                        console.log('TEXT DELTA:', msg.delta);
                    }

                    if (msg.type === 'response.output_text.done' && msg.output && msg.output[0]?.content?.[0]?.text) {
                        const finalText = msg.output[0].content[0].text;
                        addMessage(finalText, "assistant");
                    }
                                            } catch (e) {
                    console.warn('Non-JSON text message', event.data);
                }
            }
        };

        return ws;
    }

    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ Float32 [-1,1] –≤ Int16 PCM, —Å –ø—Ä–æ—Å—Ç—ã–º –¥–∞—É–Ω-—Å–µ–º–ø–ª–∏–Ω–≥–æ–º 48k -> 24k –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    function floatTo16BitPCM(input, originalSampleRate) {
        let data = input;
        if (originalSampleRate === 48000) {
            const newLength = Math.floor(input.length / 2);
            const down = new Float32Array(newLength);
            for (let i = 0, j = 0; j < newLength; i += 2, j++) {
                down[j] = input[i];
            }
            data = down;
        }

        const buffer = new ArrayBuffer(data.length * 2);
        const view = new DataView(buffer);
        let offset = 0;
        for (let i = 0; i < data.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, data[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
        return buffer;
    }

    recBtn.onclick = async () => {
        const wsConn = ensureWebSocket();

        if (isRecording) {
            // –°—Ç–æ–ø –∑–∞–ø–∏—Å–∏
            isRecording = false;
            recBtn.classList.remove("recording");
            recBtn.textContent = "üé§";

            if (audioProcessor && audioSource) {
                audioSource.disconnect(audioProcessor);
                audioProcessor.disconnect(audioContext.destination);
            }
            if (micStream) {
                micStream.getTracks().forEach(t => t.stop());
            }

            // –°–æ–æ–±—â–∞–µ–º Realtime API, —á—Ç–æ –∞—É–¥–∏–æ–±—É—Ñ–µ—Ä –∑–∞–∫–æ–Ω—á–µ–Ω –∏ –Ω—É–∂–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç
            if (wsConn.readyState === WebSocket.OPEN) {
                wsConn.send(JSON.stringify({ type: 'input_audio_buffer.commit' }));
                wsConn.send(JSON.stringify({ type: 'response.create' }));
            }
            return;
        }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                    autoGainControl: true
                }
            });

            micStream = stream;

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const source = audioContext.createMediaStreamSource(stream);
            const processor = audioContext.createScriptProcessor(4096, 1, 1);

            processor.onaudioprocess = function (e) {
                if (!isRecording || wsConn.readyState !== WebSocket.OPEN) return;
                const inputBuffer = e.inputBuffer.getChannelData(0);
                const pcmBuffer = floatTo16BitPCM(inputBuffer, audioContext.sampleRate);
                wsConn.send(pcmBuffer);
            };

            source.connect(processor);
            processor.connect(audioContext.destination);

            audioSource = source;
            audioProcessor = processor;

            addMessage("üé§ (voice started)", "user");

            isRecording = true;
                recBtn.classList.add("recording");
                recBtn.textContent = "‚èπÔ∏è";

            } catch (error) {
                console.error('Error accessing microphone:', error);
                addMessage("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É", "assistant");
        }
    };
</script>

</body>
</html>
