<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>OpenAI Voice Assistant</title>
    <meta name="viewport" content="width=device-width">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0d1117;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #chat {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .msg {
            margin-bottom: 20px;
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 10px;
            line-height: 1.4;
        }

        .user {
            background: #1f6feb;
            margin-left: auto;
        }

        .assistant {
            background: #30363d;
            margin-right: auto;
        }

        .status {
            background: #161b22;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            color: #8b949e;
            margin-bottom: 10px;
        }

        #recordBtn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: #ff4757;
            margin: 20px auto;
            cursor: pointer;
            transition: .2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: white;
        }

        #recordBtn.recording {
            background: #2ed573;
            animation: pulse 1s infinite;
        }

        #recordBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #8b949e;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="chat"></div>

<button id="recordBtn">üé§</button>

<audio id="player" preload="auto"></audio>

<script>
    // URL streaming —Å–µ—Ä–≤–µ—Ä–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ª–æ–∫–∞–ª—å–Ω—ã–π, –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å)
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º URL —Å–µ—Ä–≤–µ—Ä–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–æ—Ç–æ–∫–æ–ª–∞
    let STREAMING_SERVER_URL;
    if (window.location.protocol === 'file:' || !window.location.hostname) {
        // –ï—Å–ª–∏ —Ñ–∞–π–ª –æ—Ç–∫—Ä—ã—Ç –ª–æ–∫–∞–ª—å–Ω–æ (file://) –∏–ª–∏ –Ω–µ—Ç hostname, –∏—Å–ø–æ–ª—å–∑—É–µ–º localhost
        STREAMING_SERVER_URL = 'http://localhost:3000';
    } else if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        STREAMING_SERVER_URL = 'http://localhost:3000';
    } else {
        // –í –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ –¥–æ–º–µ–Ω
        STREAMING_SERVER_URL = window.location.origin;
    }
    
    const apiUrl = `${STREAMING_SERVER_URL}/api/voice`;
    
    console.log('Server URL:', STREAMING_SERVER_URL);
    console.log('API URL:', apiUrl);

    let mediaRecorder;
    let chunks = [];
    let isProcessing = false;

    const chat = document.getElementById("chat");
    const recBtn = document.getElementById("recordBtn");
    const player = document.getElementById("player");

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è sessionId
    let sessionId = localStorage.getItem('sessionId');
    if (!sessionId) {
        sessionId = crypto.randomUUID();
        localStorage.setItem('sessionId', sessionId);
    }

    function addMessage(text, who) {
        const div = document.createElement("div");
        div.className = "msg " + who;
        div.textContent = text;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        return div;
    }

    function addStatus(text) {
        const div = document.createElement("div");
        div.className = "status";
        div.innerHTML = `<span class="loading"></span> ${text}`;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        return div;
    }

    // –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è streaming –º–µ—Ç—Ä–∏–∫
    let streamingMetrics = {
        requestStartTime: null,
        firstChunkTime: null,
        firstAudioTime: null,
        chunkCount: 0
    };

    function updateStatus(statusDiv, text) {
        if (statusDiv) {
            statusDiv.innerHTML = `<span class="loading"></span> ${text}`;
        }
    }

    function removeStatus(statusDiv) {
        if (statusDiv && statusDiv.parentNode) {
            statusDiv.parentNode.removeChild(statusDiv);
        }
    }

    // –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è streaming –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ
    // –ü—Ä–æ—Å—Ç–æ–π –ø–æ–¥—Ö–æ–¥: –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ, –Ω–∞—á–∏–Ω–∞–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Ä–∞–Ω–æ, –æ–±–Ω–æ–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ
    async function playStreamingAudio(response, statusDiv = null) {
        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ª–∏ –æ—Ç–≤–µ—Ç streaming
            if (response.body && response.body.getReader) {
                const reader = response.body.getReader();
                const chunks = [];
                const contentType = response.headers.get('content-type') || 'audio/mpeg';
                let blobUrl = null;
                let hasStarted = false;
                const MIN_CHUNKS_TO_START = 2;
                const MIN_BYTES_TO_START = 10000; // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–æ 10KB –¥–ª—è –±–æ–ª–µ–µ —Å—Ç–∞–±–∏–ª—å–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è

                return new Promise((resolve, reject) => {
                    // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —á—Ç–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞
                    (async () => {
                        try {
                            while (true) {
                                const { done, value } = await reader.read();
                                
                                if (done) {
                                    // –ü–æ—Ç–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω
                                    if (chunks.length === 0) {
                                        reject(new Error('No audio data received'));
                                        return;
                                    }
                                    
                                    // –ï—Å–ª–∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–æ—Å—å, —Å–æ–∑–¥–∞–µ–º blob –∏ –Ω–∞—á–∏–Ω–∞–µ–º
                                    if (!hasStarted) {
                                        const finalBlob = new Blob(chunks, { type: contentType });
                                        blobUrl = URL.createObjectURL(finalBlob);
                                        player.src = blobUrl;
                                        
                                        try {
                                            await player.play();
                                            hasStarted = true;
                                            streamingMetrics.firstAudioTime = Date.now();
                                        } catch (playError) {
                                            console.log('Play error:', playError);
                                        }
                                    } else {
                                        // –ï—Å–ª–∏ —É–∂–µ –∏–≥—Ä–∞–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å —Å –ø–æ–ª–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
                                        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç—Ä–µ–∫ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è (—á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ—Ä–≤–∞—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ)
                                        if (player.ended) {
                                            // –¢—Ä–µ–∫ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è, –æ–±–Ω–æ–≤–ª—è–µ–º —Å –ø–æ–ª–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
                                            const finalBlob = new Blob(chunks, { type: contentType });
                                            if (blobUrl) {
                                                URL.revokeObjectURL(blobUrl);
                                            }
                                            blobUrl = URL.createObjectURL(finalBlob);
                                            player.src = blobUrl;
                                            player.currentTime = 0;
                                            try {
                                                await player.play();
                                            } catch (e) {
                                                console.log('Play error on update:', e);
                                            }
                                        }
                                        // –ï—Å–ª–∏ —Ç—Ä–µ–∫ –µ—â–µ –∏–≥—Ä–∞–µ—Ç, –ø—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –µ–≥–æ –∏–≥—Ä–∞—Ç—å
                                        // MP3 –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç progressive download, –ø–æ—ç—Ç–æ–º—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ src –ø—Ä–µ—Ä–≤–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
                                    }
                                    
                                    // –ñ–¥–µ–º –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
                                    player.onended = () => {
                                        const totalTime = Date.now() - streamingMetrics.requestStartTime;
                                        console.log(`üìä Streaming Complete:`);
                                        console.log(`  - Total chunks: ${streamingMetrics.chunkCount}`);
                                        console.log(`  - Time to first chunk: ${streamingMetrics.firstChunkTime ? streamingMetrics.firstChunkTime - streamingMetrics.requestStartTime : 0}ms`);
                                        console.log(`  - Time to first audio: ${streamingMetrics.firstAudioTime ? streamingMetrics.firstAudioTime - streamingMetrics.requestStartTime : 0}ms`);
                                        console.log(`  - Total time: ${totalTime}ms`);
                                        
                                        if (blobUrl) {
                                            URL.revokeObjectURL(blobUrl);
                                        }
                                        resolve();
                                    };
                                    
                                    // –ï—Å–ª–∏ —Ç—Ä–µ–∫ —É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è, —Å—Ä–∞–∑—É —Ä–µ–∑–æ–ª–≤–∏–º
                                    if (player.ended) {
                                        if (blobUrl) {
                                            URL.revokeObjectURL(blobUrl);
                                        }
                                        resolve();
                                    }
                                    
                                    break;
                                }
                                
                                // –î–æ–±–∞–≤–ª—è–µ–º —á–∞–Ω–∫
                                chunks.push(value);
                                streamingMetrics.chunkCount++;
                                
                                if (!streamingMetrics.firstChunkTime) {
                                    streamingMetrics.firstChunkTime = Date.now();
                                    const timeToFirstChunk = streamingMetrics.firstChunkTime - streamingMetrics.requestStartTime;
                                    console.log(`‚è±Ô∏è First chunk received in ${timeToFirstChunk}ms`);
                                    if (statusDiv) {
                                        updateStatus(statusDiv, `–ü–æ–ª—É—á–µ–Ω –ø–µ—Ä–≤—ã–π —á–∞–Ω–∫ (${timeToFirstChunk}ms)`);
                                    }
                                }
                                
                                // –ù–∞—á–∏–Ω–∞–µ–º –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∫–∞–∫ —Ç–æ–ª—å–∫–æ –Ω–∞–∫–æ–ø–∏—Ç—Å—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
                                if (!hasStarted) {
                                    const totalBytes = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                                    
                                    if (chunks.length >= MIN_CHUNKS_TO_START && totalBytes >= MIN_BYTES_TO_START) {
                                        // –°–æ–∑–¥–∞–µ–º blob –∏–∑ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö —á–∞–Ω–∫–æ–≤
                                        const initialBlob = new Blob(chunks, { type: contentType });
                                        blobUrl = URL.createObjectURL(initialBlob);
                                        player.src = blobUrl;
                                        
                                        // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞—á–∞—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
                                        try {
                                            await player.play();
                                            hasStarted = true;
                                            streamingMetrics.firstAudioTime = Date.now();
                                            const timeToFirstAudio = streamingMetrics.firstAudioTime - streamingMetrics.requestStartTime;
                                            console.log(`üéµ Streaming playback started! Time to first audio: ${timeToFirstAudio}ms`);
                                            console.log(`üìä Received ${streamingMetrics.chunkCount} chunks before playback`);
                                            if (statusDiv) {
                                                updateStatus(statusDiv, `üéµ –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –Ω–∞—á–∞–ª–æ—Å—å (${timeToFirstAudio}ms)`);
                                            }
                                        } catch (playError) {
                                            console.log('Auto-play prevented, will retry when more data arrives:', playError);
                                            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –Ω–∞–∫–∞–ø–ª–∏–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ
                                        }
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Streaming read error:', error);
                            if (blobUrl) {
                                URL.revokeObjectURL(blobUrl);
                            }
                            reject(error);
                        }
                    })();
                });
            } else {
                // Fallback: –æ–±—ã—á–Ω–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
                const arrayBuf = await response.arrayBuffer();
                const audioBlob = new Blob([arrayBuf], { type: "audio/mpeg" });
                const url = URL.createObjectURL(audioBlob);
                player.src = url;
                await player.play();
                
                return new Promise((resolve) => {
                    player.onended = () => {
                        URL.revokeObjectURL(url);
                        resolve();
                    };
                });
            }
        } catch (error) {
            console.error('Error playing audio:', error);
            throw error;
        }
    }

    recBtn.onclick = async () => {
        if (isProcessing) {
            return; // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
        }

        if (!mediaRecorder || mediaRecorder.state === "inactive") {
            // Start recording
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000 // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø 3: –ú–µ–Ω—å—à–∏–π sample rate = –º–µ–Ω—å—à–µ –¥–∞–Ω–Ω—ã—Ö
                    } 
                });
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus', // –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ò—Å–ø–æ–ª—å–∑—É–µ–º Opus –∫–æ–¥–µ–∫
                    audioBitsPerSecond: 16000 // –ù–∏–∑–∫–∏–π –±–∏—Ç—Ä–µ–π—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –ø–µ—Ä–µ–¥–∞—á–∏
                });

                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    isProcessing = true;
                    recBtn.disabled = true;
                    
                    const blob = new Blob(chunks, { type: "audio/webm;codecs=opus" });
                    chunks = [];

                    addMessage("üé§ (voice message)", "user");
                    const statusDiv = addStatus("–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞...");

                    const formData = new FormData();
                    formData.append("file", blob, "voice.webm");
                    formData.append("sessionId", sessionId);

                    try {
                        // –ò—Å–ø–æ–ª—å–∑—É–µ–º AbortController –¥–ª—è —Ç–∞–π–º–∞—É—Ç–æ–≤
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 —Å–µ–∫ —Ç–∞–π–º–∞—É—Ç –¥–ª—è streaming

                        updateStatus(statusDiv, "–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏...");
                        
                        console.log('Sending request to:', apiUrl);
                        const resp = await fetch(apiUrl, {
                            method: "POST",
                            body: formData,
                            signal: controller.signal,
                            headers: {
                                'Accept': 'audio/mpeg, application/octet-stream',
                                'X-Session-Id': sessionId
                            }
                        });
                        console.log('Response status:', resp.status, 'Content-Type:', resp.headers.get('content-type'));

                        clearTimeout(timeoutId);

                        if (!resp.ok) {
                            throw new Error(`HTTP error! status: ${resp.status}`);
                        }

                        updateStatus(statusDiv, "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞...");
                        
                        // –ù–∞—á–∏–Ω–∞–µ–º streaming –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
                        streamingMetrics.requestStartTime = Date.now();
                        streamingMetrics.chunkCount = 0;
                        await playStreamingAudio(resp, statusDiv);
                        
                        removeStatus(statusDiv);
                        addMessage("üîä (assistant is speaking)", "assistant");

                    } catch (error) {
                        removeStatus(statusDiv);
                        if (error.name === 'AbortError') {
                            addMessage("‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞", "assistant");
                        } else {
                            addMessage(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, "assistant");
                        }
                        console.error('Error:', error);
                    } finally {
                        isProcessing = false;
                        recBtn.disabled = false;
                        
                        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö —Ç—Ä–µ–∫–æ–≤ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤
                        stream.getTracks().forEach(track => track.stop());
                    }
                };

                mediaRecorder.start();
                recBtn.classList.add("recording");
                recBtn.textContent = "‚èπÔ∏è";

            } catch (error) {
                console.error('Error accessing microphone:', error);
                addMessage("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É", "assistant");
            }

        } else {
            // Stop recording
            if (mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
                recBtn.classList.remove("recording");
                recBtn.textContent = "üé§";
            }
        }
    };
</script>

</body>
</html>
